<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>$CSS_CONTENT$</style>
    <script src="file:///$MARKED_JS_PATH$"></script>
    <script src="file:///$MERMAID_JS_PATH$"></script>
    <style>
        .back-button {
            position: fixed;
            top: 12px;
            left: 50px;
            z-index: 1000;
            padding: 6px 12px;
            background: #1976d2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: background 0.2s;
        }
        .back-button:hover {
            background: #1565c0;
        }
        .back-button svg {
            width: 16px;
            height: 16px;
        }
        /* Line number gutter */
        #gutter {
            position: fixed;
            left: 0;
            top: 0;
            width: 38px;
            height: 100%;
            background: #f0f4f8;
            border-right: 1px solid #90caf9;
            overflow: hidden;
            z-index: 100;
            font-family: "SFMono-Regular", Consolas, monospace;
            font-size: 11px;
            color: #90a4ae;
            user-select: none;
        }
        #gutter-content {
            position: relative;
            padding-top: 30px;
        }
        .gutter-line {
            position: absolute;
            width: 100%;
            text-align: right;
            padding-right: 6px;
            box-sizing: border-box;
            cursor: pointer;
        }
        .gutter-line:hover {
            background: #e3f2fd;
            color: #1976d2;
        }
        .gutter-line.selected {
            background: #bbdefb;
            color: #1565c0;
        }
        .gutter-line.heading {
            font-weight: bold;
            color: #1976d2;
        }
        /* Copy toast notification */
        #copy-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: rgba(13, 71, 161, 0.9);
            color: white;
            padding: 8px 20px;
            border-radius: 6px;
            font-size: 12px;
            font-family: "Meiryo UI", "Meiryo", sans-serif;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
        }
        #copy-toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        /* Adjust body for gutter */
        body {
            margin-left: 42px !important;
            padding-left: 25px !important;
        }
        /* Line numbers in TOC */
        .toc-line-num {
            font-size: 9px;
            color: #9e9e9e;
            margin-left: 4px;
            font-family: "SFMono-Regular", Consolas, monospace;
        }
    </style>
</head>
<body>
    <!-- Line Number Gutter -->
    <div id="gutter">
        <div id="gutter-content"></div>
    </div>

    <!-- Back Button (Floating) -->
    <button class="back-button" id="back-button" style="$BACK_BUTTON_STYLE$" onclick="window.location.href='app://back'">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
        Back
    </button>

    <div id="content"></div>
    <div id="copy-toast"></div>

    <!-- Overview Sidebar (Right) -->
    <div id="sidebar-container" class="sidebar-container">
        <button class="sidebar-toggle" onclick="toggleOverview()">Outline</button>
        <div id="overview-box" class="overview-box">
            <h4>Outline</h4>
            <ul id="toc-list"></ul>
        </div>
    </div>


    <script>
        // Global error handlers to prevent crashes
        window.addEventListener('error', function(e) {
            console.error('Global error:', e.message);
            e.preventDefault();
        });
        window.addEventListener('unhandledrejection', function(e) {
            console.error('Unhandled promise rejection:', e.reason);
            e.preventDefault();
        });

        console.log('DEBUG: Script started');

        // Line info from Python
        const lineInfo = $LINE_INFO$;
        const rawLines = $RAW_LINES$;
        const filePath = "$FILE_PATH$";

        // Gutter click state
        let gutterFirstLine = null;
        let gutterSelectedElements = [];

        function clearGutterSelection() {
            gutterSelectedElements.forEach(el => el.classList.remove('selected'));
            gutterSelectedElements = [];
            gutterFirstLine = null;
        }

        function showToast(message) {
            const toast = document.getElementById('copy-toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 1500);
        }

        function getGutterLineNumber(el) {
            return parseInt(el.textContent, 10);
        }

        function selectGutterRange(startLine, endLine) {
            clearGutterSelection();
            const gutterLines = document.querySelectorAll('.gutter-line');
            gutterLines.forEach(el => {
                const num = getGutterLineNumber(el);
                if (num >= startLine && num <= endLine) {
                    el.classList.add('selected');
                    gutterSelectedElements.push(el);
                }
            });
        }

        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }

        function copyLineRange(startLine, endLine) {
            // Extract raw source lines (1-indexed to 0-indexed)
            const selectedLines = rawLines.slice(startLine - 1, endLine);
            const lineRef = startLine === endLine
                ? filePath + ':' + startLine
                : filePath + ':' + startLine + '-' + endLine;
            const text = lineRef + '\n' + selectedLines.join('\n');

            copyToClipboard(text);
            const count = endLine - startLine + 1;
            showToast('Copied ' + count + ' line' + (count > 1 ? 's' : ''));
        }

        // Configure mermaid
        if (typeof mermaid !== 'undefined') {
            mermaid.initialize({ startOnLoad: false, theme: 'default' });
        }

        // Custom renderer for mermaid code blocks
        const renderer = {
            code(codeOrObj, language) {
                let code, lang;
                if (typeof codeOrObj === 'object' && codeOrObj !== null) {
                    code = codeOrObj.text || codeOrObj.code || '';
                    lang = codeOrObj.lang || codeOrObj.language || '';
                } else {
                    code = codeOrObj || '';
                    lang = language || '';
                }

                if (lang === 'mermaid') {
                    return '<div class="mermaid">' + code + '</div>';
                }
                const escaped = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                return '<pre><code class="language-' + lang + '">' + escaped + '</code></pre>';
            }
        };

        if (typeof marked !== 'undefined') {
            marked.use({ renderer });
            marked.setOptions({ gfm: true, breaks: true });

            const markdown = `$MARKDOWN_CONTENT$`;
            try {
                document.getElementById('content').innerHTML = marked.parse(markdown);
                // Build gutter after rendering, then attach click handlers
                setTimeout(function() {
                    buildGutter();
                    attachGutterClickHandlers();
                }, 50);
            } catch (e) {
                console.error('DEBUG: marked.parse error:', e);
            }
        } else {
            document.getElementById('content').innerHTML = '<pre>' + `$MARKDOWN_CONTENT$` + '</pre>';
        }

        // Build line number gutter
        function buildGutter() {
            const content = document.getElementById('content');
            const gutterContent = document.getElementById('gutter-content');
            gutterContent.innerHTML = '';

            // Collect all renderable elements in order
            const elements = [];

            // Walk through content and collect elements
            function collectElements(parent) {
                for (const child of parent.children) {
                    const tag = child.tagName;
                    if (['H1','H2','H3','H4','H5','H6','P','HR'].includes(tag)) {
                        elements.push({ el: child, type: tag.toLowerCase() });
                    } else if (tag === 'UL' || tag === 'OL') {
                        // Get each list item
                        for (const li of child.querySelectorAll(':scope > li')) {
                            elements.push({ el: li, type: 'li' });
                        }
                    } else if (tag === 'BLOCKQUOTE') {
                        // Blockquote - collect inner paragraphs or treat as one
                        const innerP = child.querySelectorAll('p');
                        if (innerP.length > 0) {
                            innerP.forEach(p => elements.push({ el: p, type: 'quote' }));
                        } else {
                            elements.push({ el: child, type: 'quote' });
                        }
                    } else if (tag === 'TABLE') {
                        // Get each table row (skip header separator)
                        const rows = child.querySelectorAll('tr');
                        rows.forEach(tr => elements.push({ el: tr, type: 'tr' }));
                    } else if (tag === 'PRE') {
                        // Code block - could show each line
                        const code = child.querySelector('code');
                        if (code) {
                            const codeLines = code.textContent.split('\n');
                            // Just mark the pre element, we'll handle lines separately
                            elements.push({ el: child, type: 'code_block', lineCount: codeLines.length });
                        } else {
                            elements.push({ el: child, type: 'code_block', lineCount: 1 });
                        }
                    } else if (child.classList && child.classList.contains('mermaid')) {
                        elements.push({ el: child, type: 'mermaid' });
                    }
                }
            }

            collectElements(content);

            // Match elements with lineInfo
            let infoIndex = 0;
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            elements.forEach((elem) => {
                if (infoIndex >= lineInfo.length) return;

                const info = lineInfo[infoIndex];

                // Type matching
                let matches = false;
                if (elem.type.startsWith('h') && info.type.startsWith('h')) matches = true;
                else if (elem.type === 'li' && info.type === 'li') matches = true;
                else if (elem.type === 'p' && info.type === 'p') matches = true;
                else if (elem.type === 'quote' && info.type === 'quote') matches = true;
                else if (elem.type === 'tr' && info.type === 'tr') matches = true;
                else if (elem.type === 'hr' && info.type === 'hr') matches = true;
                else if (elem.type === 'code_block' && (info.type === 'code_fence' || info.type === 'code_line')) matches = true;
                else if (elem.type === 'mermaid' && info.type === 'code_fence') matches = true;

                if (matches) {
                    const rect = elem.el.getBoundingClientRect();
                    const top = rect.top + scrollTop;

                    const gutterLine = document.createElement('div');
                    gutterLine.className = 'gutter-line';
                    if (info.type.startsWith('h')) {
                        gutterLine.className += ' heading';
                    }
                    gutterLine.textContent = info.line;
                    gutterLine.dataset.line = info.line;
                    gutterLine.style.top = (top - 30) + 'px';

                    gutterContent.appendChild(gutterLine);
                    infoIndex++;

                    // For code blocks, skip the code_line entries
                    if (elem.type === 'code_block' && elem.lineCount > 0) {
                        while (infoIndex < lineInfo.length && lineInfo[infoIndex].type === 'code_line') {
                            infoIndex++;
                        }
                        // Skip closing fence if present
                        if (infoIndex < lineInfo.length && lineInfo[infoIndex].type === 'code_fence') {
                            infoIndex++;
                        }
                    }
                }
            });
        }

        // Attach click handlers to gutter lines
        function attachGutterClickHandlers() {
            const gutterLines = document.querySelectorAll('.gutter-line');
            gutterLines.forEach(el => {
                el.addEventListener('click', function(e) {
                    const clickedLine = getGutterLineNumber(this);

                    if (e.shiftKey && gutterFirstLine !== null) {
                        // Shift+click: select range
                        const startLine = Math.min(gutterFirstLine, clickedLine);
                        const endLine = Math.max(gutterFirstLine, clickedLine);
                        selectGutterRange(startLine, endLine);
                        // Find the actual end: line before next gutter entry after endLine
                        const allNums = Array.from(document.querySelectorAll('.gutter-line'))
                            .map(el => getGutterLineNumber(el)).sort((a, b) => a - b);
                        const endIdx = allNums.indexOf(endLine);
                        const actualEnd = (endIdx < allNums.length - 1)
                            ? allNums[endIdx + 1] - 1
                            : rawLines.length;
                        copyLineRange(startLine, actualEnd);
                    } else {
                        // Single click: select one block
                        clearGutterSelection();
                        this.classList.add('selected');
                        gutterSelectedElements.push(this);
                        gutterFirstLine = clickedLine;

                        // Find end of this block (line before next gutter entry)
                        const allNums = Array.from(document.querySelectorAll('.gutter-line'))
                            .map(el => getGutterLineNumber(el)).sort((a, b) => a - b);
                        const idx = allNums.indexOf(clickedLine);
                        const endLine = (idx < allNums.length - 1)
                            ? allNums[idx + 1] - 1
                            : rawLines.length;
                        copyLineRange(clickedLine, endLine);
                    }
                });
            });

            // Click outside gutter to clear selection
            document.addEventListener('click', function(e) {
                if (!e.target.classList.contains('gutter-line')) {
                    clearGutterSelection();
                }
            });
        }

        // Sync gutter scroll with content scroll
        window.addEventListener('scroll', function() {
            const gutter = document.getElementById('gutter-content');
            gutter.style.transform = 'translateY(-' + window.pageYOffset + 'px)';
        });

        // Render mermaid diagrams
        if (typeof mermaid !== 'undefined') {
            mermaid.run({ querySelector: '.mermaid' }).catch(function(e) {
                console.error('DEBUG: mermaid.run error:', e);
            });
        }

        // Build Table of Contents
        function buildTOC() {
            const content = document.getElementById('content');
            const headings = content.querySelectorAll('h1, h2, h3, h4');
            const tocList = document.getElementById('toc-list');
            tocList.innerHTML = '';

            if (headings.length === 0) {
                document.getElementById('sidebar-container').style.display = 'none';
                return;
            }

            // Get heading line numbers from lineInfo
            const headingLines = lineInfo.filter(info => info.type.startsWith('h'));

            headings.forEach((heading, index) => {
                if (!heading.id) {
                    heading.id = 'heading-' + index;
                }

                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = '#' + heading.id;

                const lineNum = headingLines[index] ? headingLines[index].line : '';
                a.innerHTML = heading.textContent + (lineNum ? ' <span class="toc-line-num">L' + lineNum + '</span>' : '');
                a.className = 'toc-' + heading.tagName.toLowerCase();
                a.onclick = function(e) {
                    e.preventDefault();
                    heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    document.querySelectorAll('.overview-box a').forEach(link => link.classList.remove('active'));
                    this.classList.add('active');
                };

                li.appendChild(a);
                tocList.appendChild(li);
            });
        }

        setTimeout(buildTOC, 100);

        // Scroll spy
        function updateActiveHeading() {
            const headings = document.querySelectorAll('#content h1, #content h2, #content h3, #content h4');
            const tocLinks = document.querySelectorAll('.overview-box a');

            let currentHeading = null;
            headings.forEach((heading, index) => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    currentHeading = index;
                }
            });

            tocLinks.forEach((link, index) => {
                link.classList.toggle('active', index === currentHeading);
            });
        }

        window.addEventListener('scroll', updateActiveHeading);

        function toggleOverview() {
            document.getElementById('sidebar-container').classList.toggle('closed');
        }

    </script>
</body>
</html>
